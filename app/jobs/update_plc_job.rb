# UpdatePlcJob - CRITICAL - Point of No Return for Account Migration
#
# This job updates the PLC (Public Ledger of Credentials) directory to point
# the user's DID to the new PDS. This is the CRITICAL step that makes the
# migration irreversible.
#
# Status Flow:
#   pending_plc -> pending_activation
#
# What This Job Does:
#   1. Retrieves user-submitted PLC token from migration record (must not be expired)
#   2. Verifies rotation key exists (generated earlier by WaitForPlcTokenJob)
#   3. Gets recommended PLC operation from new PDS
#   4. Injects user's rotation key into PLC operation (highest priority)
#   5. Signs the PLC operation with old PDS using the token
#   6. Submits the signed operation to PLC directory
#   7. Clears the encrypted PLC token for security
#   8. Advances to pending_activation
#
# Retries: 1 time only (this is critical and must succeed or fail definitively)
# Queue: :critical (highest priority)
#
# Error Handling:
#   - If the PLC token is expired or missing, fails immediately
#   - If PLC update fails, marks migration as failed with alert
#   - Logs extensively for debugging
#   - Only one retry to avoid repeated PLC operations
#
# Security:
#   - Rotation key generated by WaitForPlcTokenJob (user gets email before PLC token)
#   - Clears encrypted_plc_token after successful submission
#   - Logs all PLC operations for audit trail
#
# WARNING: Once this job completes successfully, the DID points to the new PDS.
# The old PDS should be deactivated but the user account will now resolve to
# the new PDS for all ATProto operations.

class UpdatePlcJob < ApplicationJob
  queue_as :critical
  retry_on StandardError, wait: 30.seconds, attempts: 1

  # Special handling for rate-limiting errors - retry more times for this critical job
  retry_on GoatService::RateLimitError, wait: :polynomially_longer, attempts: 3

  def perform(migration_id)
    migration = Migration.find(migration_id)
    Rails.logger.info("CRITICAL: Starting PLC update for migration #{migration.token} (#{migration.did})")
    Rails.logger.info("This is the point of no return - the DID will be pointed to the new PDS")

    # Idempotency check: Skip if already past this stage
    # NOTE: We check for pending_plc OR pending_activation because this job is triggered
    # manually by the user submitting the PLC token, and the status might still be pending_plc
    unless ['pending_plc', 'pending_activation'].include?(migration.status)
      Rails.logger.info("Migration #{migration.token} is already at status '#{migration.status}', skipping PLC update")
      return
    end

    # Step 1: Validate PLC token is present and not expired
    # NOTE: Missing/expired tokens are NOT critical failures - the PLC directory
    # hasn't been modified yet. We return early (without raising) so the rescue
    # block doesn't overwrite the error with a "CRITICAL:" prefix.
    #
    # Check expiry BEFORE the getter — the ExpirationChecks module returns nil
    # for expired tokens, so we need to distinguish "expired" from "never set".
    if migration.plc_token_expired?
      if migration.encrypted_plc_token.present?
        error_msg = "PLC token has expired (expired at: #{migration.progress_data&.dig('plc_token_expires_at')}). Please request a new token."
      else
        error_msg = "PLC token is missing. Please request a new token."
      end
      Rails.logger.error(error_msg)
      migration.mark_failed!(error_msg, error_code: :plc_token_expired)
      return
    end

    plc_token = migration.plc_token
    if plc_token.nil?
      error_msg = "PLC token is missing. Please request a new token."
      Rails.logger.error(error_msg)
      migration.mark_failed!(error_msg, error_code: :plc_token_expired)
      return
    end

    Rails.logger.info("PLC token retrieved and validated for migration #{migration.token}")

    # Step 1b: Validate all credentials needed for PLC update are available.
    # For migration_out: needs new PDS password + old PDS session
    # For migration_in: needs new PDS session (tokens) + old PDS session
    # If any are missing, this is NOT a critical failure (PLC directory hasn't been modified yet).
    missing = []
    if migration.migration_in?
      missing << "new PDS session" unless migration.has_new_pds_tokens?
    else
      missing << "new PDS password" if migration.password.nil?
    end
    missing << "old PDS session" unless migration.has_old_pds_tokens?

    if missing.any?
      error_msg = "Credentials expired: #{missing.join(' and ')} no longer available. Please re-authenticate to continue."
      Rails.logger.error(error_msg)
      migration.mark_failed!(error_msg, error_code: :credentials_need_reauth)
      return
    end

    # Initialize GoatService
    service = GoatService.new(migration)

    # Rotation key should already be generated by WaitForPlcTokenJob.
    # If somehow missing (e.g. older migration), generate it now as a fallback.
    unless migration.rotation_key.present?
      Rails.logger.warn("Rotation key missing at PLC update time — generating now as fallback")
      rotation_key = service.generate_rotation_key
      migration.set_rotation_key(rotation_key[:private_key])
      migration.progress_data['rotation_key_public'] = rotation_key[:public_key]
      migration.progress_data['rotation_key_generated_at'] = Time.current.iso8601
      migration.save!
      Rails.logger.info("Rotation key generated (fallback) — public key: #{rotation_key[:public_key]}")
    end

    # Step 2: Get recommended PLC operation from new PDS
    Rails.logger.info("Getting recommended PLC operation parameters from new PDS")
    unsigned_op_path = service.get_recommended_plc_operation

    # Update progress
    migration.progress_data['plc_operation_recommended_at'] = Time.current.iso8601
    migration.save!

    # Step 2b: Inject user's rotation key into the unsigned PLC operation
    # This ensures the key is part of the PLC update itself, giving the user
    # signing authority over their DID from the moment the operation is submitted.
    rotation_key_public = migration.progress_data['rotation_key_public']
    if rotation_key_public.present?
      Rails.logger.info("Injecting user rotation key into PLC operation (highest priority)")
      unsigned_op = JSON.parse(File.read(unsigned_op_path))
      rotation_keys = unsigned_op['rotationKeys'] || []
      rotation_keys = [rotation_key_public] + rotation_keys.reject { |k| k == rotation_key_public }
      unsigned_op['rotationKeys'] = rotation_keys
      File.write(unsigned_op_path, unsigned_op.to_json)
      Rails.logger.info("Rotation key injected at front of rotationKeys array (#{rotation_keys.length} keys total)")
    end

    # Step 3: Sign the PLC operation with old PDS
    Rails.logger.info("Signing PLC operation with old PDS using token")
    signed_op_path = service.sign_plc_operation(unsigned_op_path, plc_token)

    # Update progress
    migration.progress_data['plc_operation_signed_at'] = Time.current.iso8601
    migration.save!

    # Step 4: Submit the signed operation to PLC directory
    Rails.logger.info("CRITICAL: Submitting signed PLC operation to directory")
    service.submit_plc_operation(signed_op_path)

    # Update progress
    migration.progress_data['plc_operation_submitted_at'] = Time.current.iso8601
    migration.save!

    Rails.logger.info("SUCCESS: PLC operation submitted successfully for migration #{migration.token}")
    Rails.logger.info("DID #{migration.did} now points to new PDS: #{migration.new_pds_host}")

    # Step 5: Clear the PLC token for security
    Rails.logger.info("Clearing encrypted PLC token for security")
    migration.update!(encrypted_plc_token: nil)

    # Step 6: Advance to pending_activation
    Rails.logger.info("Advancing to pending_activation")
    migration.advance_to_pending_activation!

    Rails.logger.info("PLC update completed successfully for migration #{migration.token}")

  rescue GoatService::RateLimitError => e
    Rails.logger.warn("PLC JOB: Rate limit hit for migration #{migration.token}: #{e.message}")
    Rails.logger.warn("Will retry with exponential backoff (up to 3 attempts for this critical job)")
    migration.update(last_error: "Rate limit: #{e.message}")
    raise  # Re-raise to trigger ActiveJob retry with polynomially_longer backoff

  rescue GoatService::AuthenticationError, GoatService::NetworkError, GoatService::GoatError, StandardError => e
    plc_submitted = migration&.progress_data&.dig('plc_operation_submitted_at').present?

    if plc_submitted
      # POST-SUBMISSION: The PLC directory may have been modified — this IS critical
      Rails.logger.error("CRITICAL FAILURE: Error AFTER PLC submission for migration #{migration.token}: #{e.message}")
      Rails.logger.error(e.backtrace.join("\n")) if e.backtrace
      Rails.logger.error("PLC directory may have been modified - manual intervention required")
      migration.mark_failed!("CRITICAL: PLC update failed after submission - #{e.message}", error_code: :critical_plc)
      alert_admin_of_critical_failure(migration, e)
    else
      # PRE-SUBMISSION: The PLC directory was NOT modified — this is recoverable
      Rails.logger.error("PLC update failed BEFORE submission for migration #{migration&.token || migration_id}: #{e.message}")
      Rails.logger.error(e.backtrace.join("\n")) if e.backtrace

      if migration
        # Detect PLC OTP token expiry (old PDS returned "Token is expired" during signing)
        if e.message.match?(/sign PLC operation.*Token is expired|Token is expired.*sign/i) ||
           e.message.match?(/400 Bad Request.*Token is expired/i)
          error_msg = "PLC confirmation code expired. The code from your old PDS is only valid for a limited time. Please request a new one."
          migration.mark_failed!(error_msg, error_code: :plc_token_expired)
        else
          error_msg = "PLC update failed (before submission) - #{e.message}"
          migration.mark_failed!(error_msg, error_code: :plc_pre_submission_failure)
        end
        alert_user_of_plc_token_failure(migration, e)
      end
    end
    raise
  end

  private

  def alert_admin_of_critical_failure(migration, error)
    # Log prominently for admin monitoring
    Rails.logger.error("=" * 80)
    Rails.logger.error("CRITICAL MIGRATION FAILURE - ADMIN ALERT")
    Rails.logger.error("Migration Token: #{migration.token}")
    Rails.logger.error("DID: #{migration.did}")
    Rails.logger.error("Email: #{migration.email}")
    Rails.logger.error("Error: #{error.class.name} - #{error.message}")
    Rails.logger.error("Status: PLC update SUBMITTED but post-submission step failed - requires manual recovery")
    Rails.logger.error("=" * 80)

    # Send critical failure email to user (only for post-submission failures)
    begin
      MigrationMailer.critical_plc_failure(migration).deliver_later
      Rails.logger.info("Sent critical failure notification to #{migration.email}")
    rescue => email_error
      Rails.logger.error("Failed to send critical failure email: #{email_error.message}")
    end
  end

  def alert_user_of_plc_token_failure(migration, error)
    # Non-critical: PLC was NOT updated, user can request a new token
    Rails.logger.warn("=" * 80)
    Rails.logger.warn("PLC UPDATE FAILED (PRE-SUBMISSION) - RECOVERABLE")
    Rails.logger.warn("Migration Token: #{migration.token}")
    Rails.logger.warn("DID: #{migration.did}")
    Rails.logger.warn("Error: #{error.class.name} - #{error.message}")
    Rails.logger.warn("PLC directory was NOT modified - user can request a new PLC token")
    Rails.logger.warn("=" * 80)

    # Send a non-scary email telling the user to request a new PLC token
    begin
      MigrationMailer.plc_token_failed(migration).deliver_later
      Rails.logger.info("Sent PLC token failure notification to #{migration.email}")
    rescue => email_error
      Rails.logger.error("Failed to send PLC token failure email: #{email_error.message}")
    end
  end
end
